# SQL Gaps & Migrations Futures - Audit 2026-01-21

**‚ö†Ô∏è ATTENTION : NE PAS APPLIQUER CES MIGRATIONS MAINTENANT**

Ce document liste les gaps SQL identifi√©s et propose des migrations futures.
**Le syst√®me est fonctionnel en l'√©tat** - ces am√©liorations sont optionnelles.

---

## üìä √âTAT ACTUEL DATABASE

### Tables Existantes ‚úÖ

**Module Finance** (migration `20251222_012_create_financial_tables.sql`) :
```sql
‚úÖ financial_documents (14 colonnes m√©tier)
   - qonto_invoice_id TEXT UNIQUE ‚úÖ
   - sales_order_id UUID FK ‚úÖ
   - document_type ENUM ‚úÖ
   - status ENUM ‚úÖ
   - qonto_sync_status ENUM ‚úÖ

‚úÖ bank_transactions (18 colonnes)
‚úÖ financial_payments (10 colonnes)
‚úÖ qonto_clients (9 colonnes)
‚úÖ qonto_sync_logs (9 colonnes)
```

**Indexes Existants** :
```sql
‚úÖ idx_financial_documents_sales_order
‚úÖ idx_financial_documents_qonto_sync
‚úÖ idx_bank_transactions_matching_status
‚úÖ idx_financial_payments_document
```

**Verdict** : ‚úÖ Structure DB compl√®te, pas de migration DB n√©cessaire

---

## üîß GAP 1 : Utilisation Champs Existants

### Probl√®me

Les colonnes existent mais ne sont PAS utilis√©es par les API routes :

```sql
-- Colonne existe (ligne 181 de la migration)
financial_documents.qonto_invoice_id TEXT
financial_documents.sales_order_id UUID
```

Mais :
```typescript
// API ne l'utilise pas (ligne 417 de route.ts)
// TODO: Optionnel - stocker la r√©f√©rence dans financial_documents
```

### Solution (Code TypeScript, PAS SQL)

**Fichier** : `apps/back-office/src/app/api/qonto/invoices/route.ts`

```typescript
// APR√àS ligne 409
const invoice = await qontoClient.createClientInvoice(invoiceParams);

// AJOUTER
const supabase = createAdminClient();
const { error: dbError } = await supabase
  .from('financial_documents')
  .insert({
    document_type: 'customer_invoice',
    document_direction: 'inbound',
    document_number: invoice.number,
    document_date: invoice.issue_date,
    due_date: invoice.due_date,

    // Montants
    total_ht: parseFloat(invoice.total_before_tax || '0'),
    total_ttc: invoice.total_amount_cents / 100,
    tva_amount: (invoice.vat_amount_cents || 0) / 100,

    // Statut
    status: invoice.status === 'draft' ? 'draft' : 'sent',
    amount_paid: 0,

    // Partenaire (client)
    partner_id: typedOrder.customer_id,
    partner_type: 'customer',

    // ‚Üê LIENS CRITIQUES
    sales_order_id: salesOrderId,
    qonto_invoice_id: invoice.id,
    qonto_invoice_number: invoice.number,
    qonto_pdf_url: invoice.pdf_url,
    qonto_public_url: invoice.public_url,
    qonto_client_id: qontoClientId,

    // Sync
    qonto_sync_status: 'synced',
    qonto_synced_at: new Date().toISOString(),

    // Dates
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
  });

if (dbError) {
  console.error('Failed to save invoice to DB:', dbError);
  // Continue anyway (facture Qonto cr√©√©e)
}
```

**Avantage** : Aucune migration DB n√©cessaire, juste utiliser colonnes existantes

---

## üîß GAP 2 : Sync Invoices - Mauvais Champ

### Probl√®me

**Fichier** : `apps/back-office/src/app/api/qonto/sync-invoices/route.ts`
**Ligne** : 206

```typescript
// ACTUEL (incorrect)
const documentData = {
  abby_invoice_id: invoice.id,  // ‚Üê Mauvais champ !
  abby_invoice_number: invoiceNumber,
  // ... pas de sales_order_id
};
```

### Solution (Code TypeScript, PAS SQL)

```typescript
// REMPLACER par
const documentData = {
  // Champs Qonto (corrects)
  qonto_invoice_id: invoice.id,
  qonto_invoice_number: invoiceNumber,

  // Rechercher sales_order_id par num√©ro
  sales_order_id: await findOrderIdByPurchaseOrderNumber(
    invoice.purchase_order_number,
    supabase
  ),

  // ... autres champs
};

// Helper function √† ajouter
async function findOrderIdByPurchaseOrderNumber(
  purchaseOrderNumber: string | undefined,
  supabase: SupabaseClient
): Promise<string | null> {
  if (!purchaseOrderNumber) return null;

  const { data } = await supabase
    .from('sales_orders')
    .select('id')
    .eq('order_number', purchaseOrderNumber)
    .maybeSingle();

  return data?.id || null;
}
```

**Avantage** : Pas de migration DB, juste corriger le code

---

## üìã MIGRATIONS FUTURES OPTIONNELLES

**Note** : Ces migrations sont **optionnelles** car la structure actuelle est suffisante.

### Migration Future 1 : Vue Tra√ßabilit√© Compl√®te

**‚ö†Ô∏è NE PAS CR√âER MAINTENANT**

Cette vue faciliterait les requ√™tes tra√ßabilit√© commande ‚Üí facture ‚Üí paiement.

```sql
-- Migration: 20260XXX_XXX_view_order_invoice_payment_traceability.sql
-- √Ä cr√©er APR√àS correction code API (Gap 1 et 2)

CREATE OR REPLACE VIEW v_order_invoice_payment_traceability AS
SELECT
  -- Commande
  so.id AS order_id,
  so.order_number,
  so.created_at AS order_date,
  so.total_ttc AS order_total,
  so.status AS order_status,
  so.payment_status,

  -- Client
  org.trade_name AS customer_name,
  org.email AS customer_email,

  -- Channel
  ch.name AS channel,

  -- Facture
  fd.id AS invoice_id,
  fd.document_number AS invoice_number,
  fd.document_date AS invoice_date,
  fd.due_date AS invoice_due_date,
  fd.total_ttc AS invoice_total,
  fd.status AS invoice_status,
  fd.amount_paid AS invoice_amount_paid,

  -- Qonto Invoice
  fd.qonto_invoice_id,
  fd.qonto_invoice_number,
  fd.qonto_pdf_url,
  fd.qonto_public_url,
  fd.qonto_sync_status,

  -- Paiements
  COALESCE(
    (SELECT json_agg(json_build_object(
      'payment_id', fp.id,
      'amount', fp.amount_paid,
      'date', fp.payment_date,
      'method', fp.payment_method,
      'transaction_id', bt.transaction_id,
      'transaction_amount', bt.amount
    ))
    FROM financial_payments fp
    LEFT JOIN bank_transactions bt ON bt.id = fp.bank_transaction_id
    WHERE fp.document_id = fd.id),
    '[]'::json
  ) AS payments,

  -- Flags utiles
  (fd.id IS NOT NULL) AS has_invoice,
  (fd.qonto_invoice_id IS NOT NULL) AS synced_to_qonto,
  (fd.amount_paid >= fd.total_ttc) AS is_fully_paid,
  (fd.due_date < CURRENT_DATE AND fd.status != 'paid') AS is_overdue,

  -- Audit
  so.created_at,
  so.updated_at

FROM sales_orders so
LEFT JOIN channels ch ON ch.id = so.channel_id
LEFT JOIN organisations org ON org.id = so.customer_id
LEFT JOIN financial_documents fd ON fd.sales_order_id = so.id
  AND fd.document_type = 'customer_invoice'
  AND fd.deleted_at IS NULL

WHERE so.channel_id = (SELECT id FROM channels WHERE name = 'LinkMe')

ORDER BY so.created_at DESC;

-- Permissions
GRANT SELECT ON v_order_invoice_payment_traceability TO authenticated;

-- Commentaire
COMMENT ON VIEW v_order_invoice_payment_traceability IS
  'Vue unifi√©e pour tra√ßabilit√© commandes LinkMe ‚Üí factures Qonto ‚Üí paiements';
```

**Utilisation** :
```sql
-- Voir toutes commandes sans facture
SELECT order_id, order_number, order_date
FROM v_order_invoice_payment_traceability
WHERE has_invoice = false;

-- Voir factures non pay√©es en retard
SELECT order_number, invoice_number, invoice_due_date, invoice_total
FROM v_order_invoice_payment_traceability
WHERE is_overdue = true;

-- Tracer une commande sp√©cifique
SELECT *
FROM v_order_invoice_payment_traceability
WHERE order_number = 'LM-2026-001';
```

---

### Migration Future 2 : Fonction Helper R√©conciliation

**‚ö†Ô∏è NE PAS CR√âER MAINTENANT**

```sql
-- Migration: 20260XXX_XXX_function_auto_reconcile_payment.sql

CREATE OR REPLACE FUNCTION auto_reconcile_payment(
  p_transaction_id UUID,
  p_invoice_id UUID
) RETURNS TABLE (
  success BOOLEAN,
  message TEXT,
  payment_id UUID
) AS $$
DECLARE
  v_transaction bank_transactions;
  v_invoice financial_documents;
  v_payment_id UUID;
BEGIN
  -- R√©cup√©rer transaction
  SELECT * INTO v_transaction
  FROM bank_transactions
  WHERE id = p_transaction_id;

  IF NOT FOUND THEN
    RETURN QUERY SELECT false, 'Transaction not found', NULL::UUID;
    RETURN;
  END IF;

  -- R√©cup√©rer facture
  SELECT * INTO v_invoice
  FROM financial_documents
  WHERE id = p_invoice_id;

  IF NOT FOUND THEN
    RETURN QUERY SELECT false, 'Invoice not found', NULL::UUID;
    RETURN;
  END IF;

  -- V√©rifier montants coh√©rents (tol√©rance 1‚Ç¨)
  IF ABS(v_transaction.amount - v_invoice.total_ttc) > 1 THEN
    RETURN QUERY SELECT false,
      format('Amount mismatch: transaction %.2f != invoice %.2f',
        v_transaction.amount, v_invoice.total_ttc),
      NULL::UUID;
    RETURN;
  END IF;

  -- Cr√©er paiement
  INSERT INTO financial_payments (
    document_id,
    bank_transaction_id,
    amount_paid,
    currency,
    payment_date,
    payment_method,
    qonto_transaction_id,
    synced_from_qonto_at,
    created_at
  )
  VALUES (
    v_invoice.id,
    v_transaction.id,
    v_transaction.amount,
    v_transaction.currency,
    COALESCE(v_transaction.settled_at, v_transaction.emitted_at),
    'virement',
    v_transaction.transaction_id,
    NOW(),
    NOW()
  )
  RETURNING id INTO v_payment_id;

  -- Mettre √† jour matching status transaction
  UPDATE bank_transactions
  SET
    matching_status = 'auto_matched',
    matched_document_id = v_invoice.id,
    confidence_score = 100,
    match_reason = 'Auto-reconciled by function',
    matched_at = NOW()
  WHERE id = p_transaction_id;

  -- Retourner succ√®s
  RETURN QUERY SELECT true,
    format('Payment created and reconciled (%.2f ‚Ç¨)', v_transaction.amount),
    v_payment_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Permissions
GRANT EXECUTE ON FUNCTION auto_reconcile_payment TO authenticated;

-- Commentaire
COMMENT ON FUNCTION auto_reconcile_payment IS
  'R√©concilie automatiquement une transaction bancaire avec une facture';
```

**Utilisation** :
```typescript
// API route ou webhook
const { data, error } = await supabase.rpc('auto_reconcile_payment', {
  p_transaction_id: 'uuid-transaction',
  p_invoice_id: 'uuid-facture',
});

if (data[0].success) {
  console.log('Reconciled:', data[0].message);
  // D√©clencher notification email
} else {
  console.error('Failed:', data[0].message);
}
```

---

### Migration Future 3 : Trigger Auto-notification Overdue

**‚ö†Ô∏è NE PAS CR√âER MAINTENANT**

```sql
-- Migration: 20260XXX_XXX_trigger_invoice_overdue_notification.sql

CREATE OR REPLACE FUNCTION notify_invoice_overdue()
RETURNS TRIGGER AS $$
DECLARE
  v_order_number TEXT;
  v_customer_email TEXT;
BEGIN
  -- Ne traiter que si statut passe √† overdue
  IF NEW.status = 'overdue' AND OLD.status != 'overdue' THEN

    -- R√©cup√©rer infos commande + client
    SELECT so.order_number, org.email
    INTO v_order_number, v_customer_email
    FROM sales_orders so
    LEFT JOIN organisations org ON org.id = so.customer_id
    WHERE so.id = NEW.sales_order_id;

    -- Cr√©er notification admin
    INSERT INTO notifications (
      user_id,
      type,
      title,
      message,
      severity,
      action_url,
      action_label,
      metadata,
      created_at
    )
    SELECT
      u.id,
      'invoice_overdue',
      'Facture en retard',
      format('Facture %s (commande %s) est en retard de paiement',
        NEW.document_number, v_order_number),
      'important',
      format('/factures/%s', NEW.id),
      'Voir la facture',
      json_build_object(
        'invoice_id', NEW.id,
        'order_number', v_order_number,
        'customer_email', v_customer_email,
        'amount', NEW.total_ttc,
        'due_date', NEW.due_date
      ),
      NOW()
    FROM auth.users u
    JOIN user_app_roles uar ON uar.user_id = u.id
    WHERE uar.app = 'back-office'
      AND uar.role IN ('admin', 'finance')
      AND uar.is_active = true;

    -- TODO: D√©clencher email client automatique (via queue)

  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_invoice_overdue
  AFTER UPDATE ON financial_documents
  FOR EACH ROW
  WHEN (NEW.status IS DISTINCT FROM OLD.status)
  EXECUTE FUNCTION notify_invoice_overdue();

COMMENT ON TRIGGER trg_invoice_overdue ON financial_documents IS
  'Notifie automatiquement les admins finance quand une facture passe en retard';
```

---

## üîç REQU√äTES SQL UTILES (Audit/Debug)

### V√©rifier Tra√ßabilit√© Actuelle

```sql
-- Commandes LinkMe AVEC facture li√©e
SELECT
  so.order_number,
  so.total_ttc AS commande_total,
  fd.document_number AS facture_numero,
  fd.qonto_invoice_id,
  fd.total_ttc AS facture_total,
  fd.status AS facture_status,
  fd.amount_paid AS facture_paye
FROM sales_orders so
JOIN financial_documents fd ON fd.sales_order_id = so.id
WHERE so.channel_id = (SELECT id FROM channels WHERE name = 'LinkMe')
ORDER BY so.created_at DESC
LIMIT 20;
```

```sql
-- Commandes LinkMe SANS facture
SELECT
  so.order_number,
  so.created_at,
  so.total_ttc,
  so.status,
  so.payment_status
FROM sales_orders so
LEFT JOIN financial_documents fd ON fd.sales_order_id = so.id
WHERE so.channel_id = (SELECT id FROM channels WHERE name = 'LinkMe')
  AND fd.id IS NULL
  AND so.status NOT IN ('draft', 'cancelled')
ORDER BY so.created_at DESC;
```

### V√©rifier Sync Qonto

```sql
-- Factures dans DB utilisant mauvais champ (abby au lieu de qonto)
SELECT
  document_number,
  abby_invoice_id,
  qonto_invoice_id,
  sales_order_id,
  created_at
FROM financial_documents
WHERE document_type = 'customer_invoice'
  AND abby_invoice_id IS NOT NULL
  AND qonto_invoice_id IS NULL
ORDER BY created_at DESC
LIMIT 10;
```

```sql
-- Stats sync Qonto
SELECT
  qonto_sync_status,
  COUNT(*) AS count,
  SUM(total_ttc) AS total_amount
FROM financial_documents
WHERE document_type = 'customer_invoice'
  AND deleted_at IS NULL
GROUP BY qonto_sync_status;
```

### Factures En Retard

```sql
-- Factures overdue non pay√©es
SELECT
  fd.document_number,
  fd.document_date,
  fd.due_date,
  fd.total_ttc,
  fd.amount_paid,
  fd.total_ttc - fd.amount_paid AS reste_a_payer,
  CURRENT_DATE - fd.due_date AS jours_retard,
  so.order_number,
  org.trade_name AS client
FROM financial_documents fd
LEFT JOIN sales_orders so ON so.id = fd.sales_order_id
LEFT JOIN organisations org ON org.id = fd.partner_id
WHERE fd.document_type = 'customer_invoice'
  AND fd.status IN ('sent', 'overdue')
  AND fd.due_date < CURRENT_DATE
  AND fd.amount_paid < fd.total_ttc
  AND fd.deleted_at IS NULL
ORDER BY fd.due_date ASC;
```

### Transactions Non Rapproch√©es

```sql
-- Transactions bancaires sans facture (side = credit = encaissements)
SELECT
  bt.transaction_id,
  bt.emitted_at,
  bt.amount,
  bt.label,
  bt.counterparty_name,
  bt.matching_status,
  fd.document_number AS facture_liee
FROM bank_transactions bt
LEFT JOIN financial_documents fd ON fd.id = bt.matched_document_id
WHERE bt.side = 'credit'
  AND bt.matching_status = 'unmatched'
  AND bt.amount > 100  -- Filtrer petits montants
ORDER BY bt.emitted_at DESC
LIMIT 20;
```

---

## üìä R√âSUM√â GAPS SQL

| Gap | Type | Migration DB Requise ? | Action |
|-----|------|------------------------|--------|
| **Tra√ßabilit√© factures** | Code API | ‚ùå NON | Utiliser colonnes existantes |
| **Sync invoices champs** | Code API | ‚ùå NON | Corriger champ utilis√© |
| **Vue tra√ßabilit√©** | Nice-to-have | ‚ö†Ô∏è Optionnel | Facilite requ√™tes |
| **Fonction r√©conciliation** | Nice-to-have | ‚ö†Ô∏è Optionnel | Automatisation |
| **Trigger notifications** | Nice-to-have | ‚ö†Ô∏è Optionnel | UX am√©lior√©e |

**Verdict** : ‚úÖ **Aucune migration DB critique n√©cessaire**

Les gaps sont au niveau **code TypeScript** (API routes), pas au niveau database.

---

## ‚ö†Ô∏è AVERTISSEMENTS

### Avant Toute Migration

1. **Backup complet** :
   ```bash
   pg_dump -h localhost -U postgres verone_db > backup_$(date +%Y%m%d).sql
   ```

2. **Test en staging** : JAMAIS appliquer directement en production

3. **Rollback plan** :
   ```sql
   -- Toujours cr√©er migration DOWN
   -- 20260XXX_XXX_migration.sql
   -- 20260XXX_XXX_migration_down.sql
   ```

4. **Monitoring post-migration** :
   - V√©rifier logs erreurs
   - Monitorer performance requ√™tes
   - Tester fonctionnalit√©s critiques

### Ordre Application (Si D√©cision de Migrer)

1. ‚úÖ Corriger code API (Gap 1 + 2) - **PRIORITAIRE**
2. ‚è≥ Tester 1 semaine en production
3. ‚è≥ Cr√©er vue tra√ßabilit√© (si besoin)
4. ‚è≥ Ajouter fonction r√©conciliation (si besoin)
5. ‚è≥ Ajouter trigger notifications (si besoin)

---

**Document cr√©√©** : 2026-01-21
**Source** : Audit impl√©mentation complet
**Statut** : R√©f√©rence future (NE PAS APPLIQUER)
